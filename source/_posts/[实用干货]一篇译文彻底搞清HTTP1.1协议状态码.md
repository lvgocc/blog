
---
title: [实用干货]一篇译文彻底搞清HTTP1.1协议状态码
comments: true
tags: [http/1.1协议,http请求状态码]
//excerpt: 
categories: http
---

#译文 + 诠释

有问题的地方请配合原文食用 [走你](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)

##  Hypertext Transfer Protocol -- HTTP/1.1
节选 **RFC 2616**  sec 10  *超文本传输协议状态码*



<!--more-->


#译文 + 诠释

有问题的地方请配合原文食用 [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)

##  Hypertext Transfer Protocol -- HTTP/1.1
节选 **RFC 2616**  sec 10  *超文本传输协议状态码*




#### 10 状态码定义

每个状态码的说明如下, 包括对每个响应状态的说明 

##### 10.1 信息类状态 1xx

此类状态码仅由 *状态行* 和可选响应头组成的**临时**响应, 并以空行终止。此类状态码没有必需的标题。由于HTTP / 1.0没有定义任何1xx状态代码，因此服务器必须禁止向HTTP / 1.0客户端发送1xx响应。

即使客户不希望收到100（继续）状态消息，也必须准备在常规响应之前接受一个或多个1xx状态响应。用户代理可能会忽略意外的1xx状态响应。

如果是代理必须转发1xx, 除非代理与客户端连接关闭, 或者代理自己本身生成1xx（例如，如果代理在转发请求时会添加“hope：100-Continue”字段，则无需转发相应的100（Continue）响应。）


**诠释:**

1. 状态行: 由http协议版本 状态码 状态码描述组成的一个包含在响应头中的一段字符串

2. 1xx状态码是 HTTP/1.1协议新增的状态码, HTTP/1.0中不存在, 我们不应该向HTTP/1.0协议的客户端响应 1xx 状态码

3. 如果是代理必须转发1xx状态码 , 除非你的代理本身就会响应1xx状态码
4. 临时响应, 即这个状态是一个中间状态, 不是最终状态.

###### 10.1.1 100 Continue (继续)

客户应继续其请求。此临时响应用于通知客户端请求的初始部分已被接收并且尚未被服务器拒绝。客户端应该继续发送剩余的请求，或者，如果请求已经完成，则忽略该响应。请求完成后，服务器必须发送最终响应。

100 的目的是允许正在发送带有请求正文的请求消息的客户端确定源服务器是否愿意接受请求（基于请求标头）在客户端发送请求正文之前。在某些情况下，如果服务器在不查看正文的情况下拒绝邮件，则客户端发送正文可能是不合适的，或者效率很低。



**诠释:**

>期望在 14.20 章节也有描述, [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20)

100 的作用相当于敲门. "请进", 继续发送后续内容, 无人应答(拒绝)无需在发送后续内容, 提高效率



###### 10.1.1 101 Switching Protocols (交换协议)


服务器理解并愿意通过“升级消息头”字段（第14.42节）来满足客户端对在此连接上使用的应用协议进行更改的请求。服务器将在终止101响应的空行之后立即将协议切换到响应的“升级”标头字段所定义的协议。

仅在有利的情况下才应切换协议。例如，切换到新版本的HTTP优于旧版本，并且在传递使用此类功能的资源时，切换到实时同步协议可能是有利的。

升级通用标头允许客户端指定其支持的其他通信协议，并在服务器认为适合切换协议时使用。服务器必须使用101（交换协议）响应中的Upgrade标头字段来指示正在交换的协议。



**诠释:**

这个过程是由客户端主动发起升级指令, 在请求头 Upgrade 字段中标注出, 服务端响应成功后会返回 101 表示协议转换

##### 10.2 响应成功 2xx

此类状态码表示已成功接收并处理了客户的请求。

###### 10.2.1 200 ok (成功)

该请求已成功。响应返回的信息取决于请求中使用的方法

GET 在响应中发送与请求的资源相对应的实体;

HEAD 与请求的资源相对应的实体头字段在响应中发送，不带任何消息正文;

POST 描述或包含行动结果的实体;

TRACE 包含最终服务器接收到的请求消息的实体.


**诠释:**

在浏览器接收到响应状态为 200 的时候, 代表服务端接收并处理了请求, 但服务端响应的内容是取决于我们所使用的请求方法, 常见的我们使用 get & post 方法

这里扩展知识到 REST 接口规范, 可以自行前往阮一峰的一篇文章查看 [http://www.ruanyifeng.com/blog/2014/05/restful_api.html](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)

###### 10.2.2 201 Created (已创建)

该请求已完成，并导致创建了新资源。可以通过响应实体中返回的URI引用新创建的资源，其中最具体的URI由Location头字段给出。响应应包括一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由Content-Type标头字段中提供的媒体类型指定。源服务器必须在返回201状态代码之前创建资源。如果不能立即执行该操作，则服务器应以202（已接受）响应代替。

201响应可能包含ETag响应标头字段，该字段指示刚刚创建的所请求变量的实体标签的当前值，请参见14.19节。

**诠释:**

201响应一般用在 REST api规范中的 POST 请求响应状态码, 标识对提交的资源已保存.

这里提到了一个如果对资源不能够创建, 也就是在响应之前不能够完成这个动作, 这种场景可能会出现在我们的异步数据处理中, 那此时需要返回 202 状态码, 代表你接收了这次请求, 但还未完成对资源的操作.


###### 10.2.3 202 Accepted (接受)

该请求已被接受进行处理，但是处理尚未完成。该请求最终可能会执行，也可能不会最终执行，因为在实际进行处理时可能会不允许该请求。没有从这种异步操作中重新发送状态代码的功能。

202响应是有意拒绝的。其目的是允许服务器接受对其他进程的请求（也许是每天仅运行一次的面向批处理的进程），而无需用户代理与服务器的连接一直持续到该进程完成为止。随此响应返回的实体应包括请求当前状态的指示，以及指向状态监视器的指针或用户何时可以期望完成请求的一些估计。

**诠释:**

接收到了客户端的请求, 正在异步处理, 客户端可以继续进行其他操作, 意义同 201 场景返回该状态码


###### 10.2.4 203 Non-Authoritative Information (非权威信息)

实体标头中返回的元信息不是原始服务器可用的权威集，而是从本地或第三方副本收集的。呈现的集合可以是原始版本的子集或超集。例如，包括有关资源的本地注释信息可能会导致原始服务器已知的元信息的超集。不需要使用此响应代码，并且仅当响应为200（确定）时才适用。

**诠释:**
仍旧适用在代理服务器, 它在获取到原始内容后, 原始服务器给他响应了200, 然后代理服务器对内容进行了修改. 再返回给客户端, 在响应状态行中就会用 203 状态码注释, 此信息非权威信息, 非原信息.



###### 10.2.5 204 No Content (无内容)

服务器已满足请求，但不需要返回实体，可能要返回更新的元信息。响应可以包括实体标题形式的新的或更新的元信息，如果存在，则应与所请求的变量相关联。

如果客户端是用户代理，则不应更改导致发送请求的文档视图。尽管任何新的或更新的元信息都应该应用于当前在用户代理的活动视图中的文档，但该响应主要旨在允许输入操作而不会导致更改用户代理的活动文档视图。

204响应必须不包含消息正文，因此始终由标头字段之后的第一个空行终止。


**诠释:**
请求无响应报文, 这种操作相当于只需要看状态码就知道结果. 例如你对服务器的资源进行删除操作. 那服务器就不需要告诉你响应报文, 只需要告诉你删除的结果, 成功or失败, 所以这个结果可以直接通过状态码知道.


###### 10.2.6 205 Reset Content (重置内容)

服务器已经完成了请求，并且用户代理应该重置导致请求被发送的文档视图。该响应主要旨在允许通过用户输入进行操作的输入，然后清除给出输入的形式，以便用户可以轻松地发起另一个输入操作。响应中不得包含实体。

**诠释:**

当你在一个带有表单提交的页面, 输入了表单信息, 点击了提交按钮. 服务器处理成功, 但是希望这次提交之后表单页数据重置, 即抹掉输入的信息, 保持初始状态, 那么服务端就会返回一个 205 状态码.


###### 10.2.7 206 Partial Content (部分内容)

服务器已完成对资源的部分GET请求。该请求必须包含指示所需范围的Range标头字段（第14.35节），并且可能包含If-Range标头字段（第14.27节）以使请求成为条件请求。

响应必须包括以下头域：

 	- Either a Content-Range header field (section 14.16) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.
      - Date
      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request
      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant
        

如果206响应是使用强缓存验证器的If-Range请求的结果（请参阅第13.3.3节），则该响应不应包含其他实体标头。如果响应是使用弱验证器的If-Range请求的结果，则响应必须不包括其他实体头；这样可以避免缓存的实体与更新的标头之间的不一致。否则，响应必须包括所有对同一请求返回200（确定）响应的实体头。

如果ETag或Last-Modified头不完全匹配，则缓存不得将206响应与其他先前缓存的内容组合在一起，请参见13.5.4。

不支持Range和Content-Range头的缓存必须不缓存206（部分）响应。

**诠释:**
鄙人拙见: 断点续传

参考 [https://www.cnblogs.com/simonbaker/p/5190675.html](https://www.cnblogs.com/simonbaker/p/5190675.html)




##### 10.3 Redirection 3xx 重定向

此类状态码表示用户代理需要采取进一步的措施才能满足请求。当且仅当第二个请求中使用的方法是GET或HEAD时，才可以由用户代理执行所需的操作，而无需与用户进行交互。客户端应该检测到无限重定向循环，因为这样的循环会为每个重定向生成网络流量。

	注意：本规范的先前版本建议使用,最多五个重定向。内容开发人员应注意
      可能会有客户实施这样的固定局限性。
      
      
**诠释:**      
使用300作为响应码时, 一般在 get或head请求时, 才可以, 因为这两部分都属于资源访问, 而这部分资源在代理服务器不能够解决是, 推荐客户到目标资源地址访问, 但要由客户端检测,是不是**无限重定向.**
      
      

###### 10.3.1 300 Multiple Choices

所请求的资源与一组表示中的任何一个相对应，每个都有自己的特定位置，并且提供了代理驱动的协商信息（第12节），以便用户（或用户代理）可以选择首选的表示并重定向其请求到该位置。

除非它是HEAD请求，否则响应应包括一个实体，其中包含资源特征和位置的列表，用户或用户代理可以从中选择最合适的一个。实体格式由“内容类型”标头字段中提供的媒体类型指定。取决于格式和功能

用户代理，可以自动执行最合适的选择。但是，该规范没有为这种自动选择定义任何标准。

如果服务器具有首选的表示形式，则应在“位置”字段中包含该表示形式的特定URI；用户代理可以使用“位置”字段值进行自动重定向。除非另有说明，否则此响应是可缓存的。



**诠释:**   

我没找到, 但是找到了类似的资源, 或者找到了很多资源

[https://www.w3.org/Style/Examples/007/figures.ht](https://www.w3.org/Style/Examples/007/figures.ht)


###### 10.3.1 301 Moved Permanently





中文手册[https://cloud.tencent.com/developer/chapter/13553](https://cloud.tencent.com/developer/chapter/13553)



