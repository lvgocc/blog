(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{439:function(v,_,t){"use strict";t.r(_);var a=t(22),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"自动内存管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动内存管理"}},[v._v("#")]),v._v(" 自动内存管理")]),v._v(" "),t("blockquote",[t("p",[v._v("Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。\n—— 出自周志明《深入理解 Java 虚拟机》")])]),v._v(" "),t("p",[v._v("Java 的内存区域与内存溢出。")]),v._v(" "),t("p",[v._v("对于 Java 程序来讲，内存是由虚拟机的内存自动管理机制"),t("em",[v._v("垃圾回收")]),v._v("来进行管理的。这样便使得程序不容易出现内存溢出和内存泄漏问题。但是一旦出现内存问题，排查和解决起来便不是一件容易的事。")]),v._v(" "),t("h2",{attrs:{id:"运行时数据区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区域"}},[v._v("#")]),v._v(" 运行时数据区域")]),v._v(" "),t("ul",[t("li",[v._v("程序计数器")]),v._v(" "),t("li",[v._v("虚拟机栈")]),v._v(" "),t("li",[v._v("本地方法栈")]),v._v(" "),t("li",[v._v("堆")]),v._v(" "),t("li",[v._v("方法区 - 运行时常量池")]),v._v(" "),t("li",[v._v("直接内存")])]),v._v(" "),t("h3",{attrs:{id:"pc寄存器-程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器-程序计数器"}},[v._v("#")]),v._v(" PC寄存器（程序计数器）")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("线程私有")])]),v._v(" "),t("li",[v._v("存储"),t("strong",[v._v("当前方法的字节码位置")]),v._v("，如果是"),t("strong",[v._v("本地方法则存储 undefined")])]),v._v(" "),t("li",[v._v("唯一一个不会出现 "),t("strong",[v._v("OOM")]),v._v(" 的位置")]),v._v(" "),t("li",[v._v("方法执行时使用；")])]),v._v(" "),t("h3",{attrs:{id:"java-虚拟机栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机栈"}},[v._v("#")]),v._v(" Java 虚拟机栈")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("线程私有")])]),v._v(" "),t("li",[v._v("存储程序方法执行时的 "),t("strong",[v._v("栈帧")])]),v._v(" "),t("li",[v._v("达到栈允许最大容量抛出 "),t("strong",[v._v("StackOverflow Error")]),v._v(" 栈溢出")]),v._v(" "),t("li",[v._v("允许动态扩展，申请不到内存时抛出 "),t("strong",[v._v("OOM")]),v._v("。（允许动态扩展由虚拟机实现方自行选择，hotspot选择的则是不允许动态扩展）")]),v._v(" "),t("li",[v._v("不需要保证连续的内存")]),v._v(" "),t("li",[v._v("方法执行时使用；")])]),v._v(" "),t("p",[t("em",[v._v("注：在 hotspot 中不允许扩展栈内存，但同样会发生 OOM ，这是发生在创建线程内存申请时内存不足抛出的OOM，这里也属于栈原因引起的。")])]),v._v(" "),t("h3",{attrs:{id:"本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),t("p",[v._v("同上")]),v._v(" "),t("p",[t("em",[v._v("注：说明两者服务对象，虚拟机栈服务于 Java 程序，本地方法栈服务于 JVM 程序（native 方法）。")])]),v._v(" "),t("h3",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),t("ul",[t("li",[v._v("线程共享")]),v._v(" "),t("li",[v._v("存储类实例、数组对象")]),v._v(" "),t("li",[v._v("容量超过允许最大值时抛出 "),t("strong",[v._v("OOM")]),v._v(" 异常（允许动态扩展）")]),v._v(" "),t("li",[v._v("不需要保证连续的内存")]),v._v(" "),t("li",[v._v("创建对象时使用")])]),v._v(" "),t("h3",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),t("ul",[t("li",[v._v("线程共享")]),v._v(" "),t("li",[v._v("存储类的结构信息（方法、字段、构造函数）、运行时常量池")]),v._v(" "),t("li",[v._v("容量超过允许最大值时抛出 "),t("strong",[v._v("OOM")]),v._v(" 异常（允许动态扩展）")]),v._v(" "),t("li",[v._v("不需要保证连续的内存")]),v._v(" "),t("li",[v._v("虚拟机启动时创建")]),v._v(" "),t("li",[v._v("后被替换为元空间（这里的内容要和 hotspot 的“永久代“一起理解）")])]),v._v(" "),t("h3",{attrs:{id:"运行时常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[v._v("#")]),v._v(" 运行时常量池")]),v._v(" "),t("p",[v._v("（这部分内存区域同在方法区中体现）")]),v._v(" "),t("ul",[t("li",[v._v("线程共享")]),v._v(" "),t("li",[v._v("存储接口或类的常量池（字面量 与 "),t("strong",[v._v("符号")]),v._v("引用"),t("code",[v._v("类的全部限定名等信息")]),v._v("）")]),v._v(" "),t("li",[v._v("类加载时创建")]),v._v(" "),t("li",[v._v("创建过程使用的方法区内存大小，可能出现 "),t("strong",[v._v("OOM")]),v._v(" 异常")])]),v._v(" "),t("h3",{attrs:{id:"直接内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[v._v("#")]),v._v(" 直接内存")]),v._v(" "),t("p",[v._v("（这部分为延展内容）")]),v._v(" "),t("ul",[t("li",[v._v("不受虚拟机参数控制，直接使用主机内存，受主机内存大小限制；")]),v._v(" "),t("li",[v._v("JDK4中的 NIO 首次使用；")]),v._v(" "),t("li",[v._v("在设置JVM参数时，需考虑直接内存的使用大小，防止其过渡使用出现 "),t("strong",[v._v("OOM")]),v._v("；")]),v._v(" "),t("li",[v._v("JDK7开始将方法区移到这部分区域（永久代内容），直到 JDK8 全部移入元空间（这里指 hotspot 虚拟机）")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("作用\\名称")]),v._v(" "),t("th",[v._v("PC寄存器（程序计数器）")]),v._v(" "),t("th",[v._v("Java虚拟机、本地方法栈")]),v._v(" "),t("th",[v._v("Java 堆")]),v._v(" "),t("th",[v._v("方法区")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("异常情况")]),v._v(" "),t("td",[v._v("无")]),v._v(" "),t("td",[v._v("栈溢出、堆溢出")]),v._v(" "),t("td",[v._v("堆溢出")]),v._v(" "),t("td",[v._v("堆溢出")])]),v._v(" "),t("tr",[t("td",[v._v("需要连续内存")]),v._v(" "),t("td",[v._v("否")]),v._v(" "),t("td",[v._v("否")]),v._v(" "),t("td",[v._v("否")]),v._v(" "),t("td",[v._v("否")])]),v._v(" "),t("tr",[t("td",[v._v("存储内容")]),v._v(" "),t("td",[v._v("在执行 Java 代码时，存储字节码地址。"),t("br"),v._v("在执行本地方法时，存储 undefined")]),v._v(" "),t("td",[v._v("栈帧（每个栈帧以方法为单位）")]),v._v(" "),t("td",[v._v("类实例、数组对象")]),v._v(" "),t("td",[v._v("类的结构信息、字段、方法等")])]),v._v(" "),t("tr",[t("td",[v._v("使用时机")]),v._v(" "),t("td",[v._v("方法执行时")]),v._v(" "),t("td",[v._v("方法执行时")]),v._v(" "),t("td",[v._v("创建对象时")]),v._v(" "),t("td",[v._v("类被加载时")])]),v._v(" "),t("tr",[t("td",[v._v("线程私有")]),v._v(" "),t("td",[v._v("是")]),v._v(" "),t("td",[v._v("是")]),v._v(" "),t("td",[v._v("否")]),v._v(" "),t("td",[v._v("否")])])])]),v._v(" "),t("h1",{attrs:{id:"写在最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在最后"}},[v._v("#")]),v._v(" 写在最后")]),v._v(" "),t("p",[v._v("Java 的对象搁哪现在你清楚了吗？每天一点点，啃完虚拟机。欢迎加群一起讨论学习，大家一起学习效率很高哦")]),v._v(" "),t("hr")])}),[],!1,null,null,null);_.default=r.exports}}]);