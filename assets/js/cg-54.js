(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{467:function(t,s,n){"use strict";n.r(s);var a=n(22),v=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"实战回顾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实战回顾"}},[t._v("#")]),t._v(" 实战回顾")]),t._v(" "),n("p",[t._v("2018年11月28日 有两个客户在两个渠道购买了同一产品每人各买2笔\n系统应在29日做成交处理, 成交结束后, 更新一张记录表, 记录表根据产品代码和渠道代码作为Unique.\n成交使用已客户为维度的多线程成交.\n// 方法名为虚拟捏造, 并非实际使用方法名\n成交方法 chengjiao() 为独立事务;\nchengjiao() 方法内使用多线程的嵌套事务 NESTED doChengjiao()")]),t._v(" "),n("p",[t._v("伪代码")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 独立事务")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("chengjiao")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根据客户查出交易")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),n("span",{pre:!0,attrs:{class:"token generics"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Trade")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" lists "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTradeList")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 嵌套事务")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("doChengjiao")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br")])]),n("p",[t._v("假如数据为 渠道 001 产品 002   渠道 002 产品 002\n那更新的记录两条线程都要取更新表里面更新 001&002记录 和 002&002;\n但是问题出在线程的执行顺序;\n两个客户每个人在不同渠道买了一笔, 一共四笔交易记录;\n线程A先去更新了 001 & 002 这条记录\n线程B先去更新了 002 & 002 这条记录\n之后\n线程B又去更新 001 & 002 这条记录; (问题在这已经出现)\n线程A去更新 002 & 002 这条记录;")]),t._v(" "),n("p",[t._v("后续的线程B在更新的时候, 在等待这条记录之前的UPDATE事务提交或回滚, 而在占用这条记录的线程A想要提交需要等待002 & 002 这条记录提交或回滚, 而002 & 002这条记录正好被B线程占用, 由此造成了互相等待, 将更新表锁住.后续交易无法进行.后经人为干预(数小时后发现), 杀掉其中一条会话, 导致该会话数据回滚, 而另一个会话因为数据库等待时间过长, 数据也没有进行提交, 最后导致4笔交易全部回滚. 如果问题出在这也就没什么. 问题是每天这几笔交易都恰巧同时执行.就一直卡死. 最后在12月3号, 4笔交易成交了. 4个工作日.问题影响........ 客户是拒绝的... 不过好在客户大度, 没有计较. .. ..")]),t._v(" "),n("p",[t._v("至此将问题从生产日志取下, 分析, 复现, 解决,重新上线 共计 2周+, 期间对spring事务感悟颇深. 遂总结此文章.  整理, 学习.")]),t._v(" "),n("hr"),t._v(" "),n("h1",{attrs:{id:"sring-事务管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sring-事务管理"}},[t._v("#")]),t._v(" Sring 事务管理")]),t._v(" "),n("h4",{attrs:{id:"首先来看事务的四个特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#首先来看事务的四个特性"}},[t._v("#")]),t._v(" 首先来看事务的四个特性:")]),t._v(" "),n("ol",[n("li",[t._v("原子性\n"),n("blockquote",[n("p",[t._v("事务的执行将事务内所做的操作看做一个整体, 要么全部执行, 要么全部不执行.")])])]),t._v(" "),n("li",[t._v("隔离性 (可能导致死锁)\n"),n("blockquote",[n("p",[t._v("简单来说, 两个事务在同时进行更新时,一个事务在更新, 另一个事务需要操作时,不可能看到这条记录之前的值, 需要等到之前的事务要么执行(事务提交),要么不执行(事务回滚). 才可以继续对该记录进行操作. 这也是事务的其中一个隔离级别, 也是默认最优隔离级别  READCOMMITED 读已提交;")])])]),t._v(" "),n("li",[t._v("一致性\n"),n("blockquote",[n("p",[t._v("对于同处在一个事务中的数据而言. 需要保持所有的相关数据保持一致状态, 当事务执行完以后也要保持相关全部数据的正确性")])])]),t._v(" "),n("li",[t._v("持久性\n"),n("blockquote",[n("p",[t._v("简单来说, 事物的提交之后的数据保存到数据库中, 进行持久化处理;")])])])]),t._v(" "),n("h4",{attrs:{id:"事务的4个隔离级别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事务的4个隔离级别"}},[t._v("#")]),t._v(" 事务的4个隔离级别")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("隔离级别")]),t._v(" "),n("th",[t._v("脏读")]),t._v(" "),n("th",[t._v("不可重读")]),t._v(" "),n("th",[t._v("幻读")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("读操作未提交")]),t._v(" "),n("td",[t._v("可能")]),t._v(" "),n("td",[t._v("可能")]),t._v(" "),n("td",[t._v("可能")])]),t._v(" "),n("tr",[n("td",[t._v("读操作已提交")]),t._v(" "),n("td",[t._v("不可能")]),t._v(" "),n("td",[t._v("可能")]),t._v(" "),n("td",[t._v("可能")])]),t._v(" "),n("tr",[n("td",[t._v("可重读")]),t._v(" "),n("td",[t._v("不可能")]),t._v(" "),n("td",[t._v("不可能")]),t._v(" "),n("td",[t._v("可能")])]),t._v(" "),n("tr",[n("td",[t._v("串行化")]),t._v(" "),n("td",[t._v("不可能")]),t._v(" "),n("td",[t._v("不可能")]),t._v(" "),n("td",[t._v("不可能")])])])]),t._v(" "),n("h4",{attrs:{id:"事务的7个传播机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事务的7个传播机制"}},[t._v("#")]),t._v(" 事务的7个传播机制")]),t._v(" "),n("ol",[n("li",[t._v("REQUIRED：\t\t如果存在一个事务，支持当前事务。如果没有事务则开启")]),t._v(" "),n("li",[t._v("SUPPORTS：\t\t如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行")]),t._v(" "),n("li",[t._v("NOT_SUPPORTED：\t总是非事务地执行，并挂起任何存在的事务(不使用事务)")]),t._v(" "),n("li",[t._v("NESTED：\t\t\t如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务,  REQUIRED 属性执行")]),t._v(" "),n("li",[t._v("REQUIRES_NEW：\t总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起(自己一个事务,独立事务)")]),t._v(" "),n("li",[t._v("NEVER： \t\t\t总是非事务地执行，如果存在一个活动事务，则抛出异常(必须由非事务的方法调用)")]),t._v(" "),n("li",[t._v("MANDATORY：\t\t如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常(必须由带有事务的方法来调用)")])]),t._v(" "),n("p",[n("strong",[t._v("画重点")])]),t._v(" "),n("p",[t._v("spring的事务管理中, 让我们容易出现问题的几个传播约定")]),t._v(" "),n("ol",[n("li",[t._v("REQUIRED")]),t._v(" "),n("li",[t._v("NESTED")])]),t._v(" "),n("p",[t._v("1是默认传播机制, 2是嵌套传播机制;\nREQUIRED 如果你没有, 我就自己管自己, 如果有, 就用你的;\nNESTED 如果有, 我就听你的, 如果没有, 我就按照默认的走;")]),t._v(" "),n("p",[n("strong",[t._v("举例说明:")]),t._v("\nfun1() 方法1 "),n("strong",[t._v("是一个带事务的方法")]),t._v(", 我们将使用fun1()来调用, fun2(), 此时的方法2 fun2()我们在配置事务的时候")]),t._v(" "),n("ol",[n("li",[t._v("配置了一个 REQUIRED , 那么此时的fun2()支持fun1()的事务, 与fun1() 事务相同, 你是什么事务, 我就是什么事务.")]),t._v(" "),n("li",[t._v("配置了一个NESTED, 那么这个时候的fun2() 则是存在fun1()的事务之中, 而不是另起一个事务的存在. 他的提交与回滚, 与 fun1() 共存, fun1() 提交, 我就提交, fun1()回滚, 我就回滚;")])]),t._v(" "),n("p",[t._v("当fun1() 方法1 "),n("strong",[t._v("不是一个带事务的方法")]),t._v(" , 此时 REQUIRED 与 NESTED 意义相同; 都将自身新启事务. 独立提交或回滚;")])])}),[],!1,null,null,null);s.default=v.exports}}]);